1. 对撞指针(#对撞指针)
   1. [167. 两数之和 II - 输入有序数组](#167)
   2. [11 盛最多水的容器](#11)
   3. [345 反转字符串中的元音字母]()
   4. [344 反转字符串]()
   5. [125 验证回文串]()
   
2. 快慢指针
   1. [141 环形链表]()
   2. [142 环形链表 II]()
   
   
   
# 对撞指针<a id="对撞指针"></a>


   ## 167. 两数之和 II - 输入有序数组<a id="167"></a>
   输入: numbers = [2, 7, 11, 15], target = 9  
   输出: [1,2]  
   解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。

使用双指针，一个指针值指向较小的元素，一个指针指向值较大的元素。指向较小元素的指针从头向尾遍历，指向较大元素的指针从尾向头遍历。

- 如果两个指针指向元素的和 sum == target,则返回结果；
- 如果 sum > target, 移动较大的元素，使sum变小一些；
- 如果 sum < target, 移动较小的元素，使sum 变大一些。

```python

class Solution:
    def twoSum(self, numbers: List[int], target: int) -> List[int]:
        i = 0
        j = len(numbers) - 1
        while i < j:
            if numbers[i] + numbers[j] < target:
                i += 1
            elif numbers[i] + numbers[j] > target:
                j -= 1
            else:
                return [i+1,j+1]
```

   ## 11. 盛最多水的容器<a id="11"></a>

给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。  
说明：你不能倾斜容器，且 n 的值至少为 2。

![question_11](question_11.jpg)

输入：[1,8,6,2,5,4,8,3,7]  
输出：49

- **算法流程**： 设置双指针i，j分别位于容器壁两端，根据规则移动指针（后续说明），并更新面积做大值res，直到i==j 时返回res.



- **指针移动规则与证明**：每次选定围成水槽两版高度h[i], h[j]中的短板，向中间收窄1格。

  - 设每一状态下水槽面积为S(i,j)(0<=i<j<n), 由于水槽的实际高度由两版中的短板决定，则面积S(i,j) = min(h[i],h[j]) * (j-i).

  - 在每一个状态下，无论长版或短板收窄1格，都会导致水槽的**底边宽度-1**.

    - 若向内移动短板，水槽的短板min(h[i],h[j]) 可能变大，因此水槽面积可能增大。

    - 若向内移动长版，水槽的短板min(h[i],h[j]) 可能不变或变小，下个水槽的面积一定小于当前水槽面积。

  - 因此，向内收窄短板可以获取面积最大值。换个角度理解：
  
    - 若不指定移动规则，所有移动出现的S(i,j)的状态为C(n,2)，即暴力枚举所有状态。
    - 在状态S(i,j)下向内移动短板至S(i+1,j)(假设h[i] < h[j])， 则相当于消去了S(i,j-1)，S(i,j-2)，...，S(i,i+1)z状态集合。而所有消去状态的面积一定<= S(i,j);
    - 因此**所有消去状态面积都 <S(i,j)**。通俗的讲，我们每次向内移动短板，所有消去的状态都**不会导致丢失面积最大值**。
  
    ```python
    class Solution:
        def maxArea(self, height: List[int]) -> int:
            p1 = 0
            p2 = len(height) - 1
    
            area = (p2 - p1) * min(height[p1], height[p2])
            while p1 < p2:
                if height[p1] < height[p2]:
                    p1 += 1
                    area = max(area, (p2 - p1) * min(height[p1], height[p2]))
                else:
                    p2 -= 1
                    area = max(area, (p2 - p1) * min(height[p1], height[p2]))
            return area
    ```
  
    
